#==========================================================================================#
#==========================================================================================#
#     This function calculates the mean of the logs.                                       #
#------------------------------------------------------------------------------------------#
mean.log <<- function(x,na.rm=FALSE) exp(mean(log(x),na.rm=na.rm))
#==========================================================================================#
#==========================================================================================#





#==========================================================================================#
#==========================================================================================#
#     This function gets the first element (or the first non-NA element).                  #
#------------------------------------------------------------------------------------------#
get.1st <<- function(x,na.rm=FALSE){
   sel = (! na.rm) | (! is.na(x))
   x.sel = x[sel]
   n.sel = length(x.sel)
   if (n.sel == 0){ ans = NaN }else{ ans = x.sel[1]}
   return(ans)
}#end get.last
#==========================================================================================#
#==========================================================================================#





#==========================================================================================#
#==========================================================================================#
#     This function gets the middle element (or the middle amongst non-NA elements).       #
#------------------------------------------------------------------------------------------#
get.midst <<- function(x,na.rm=FALSE){
   sel = (! na.rm) | (! is.na(x))
   x.sel = x[sel]
   n.sel = length(x.sel)
   if (n.sel == 0){
      ans = NaN
   }else{
      use = ceiling(n.sel/2)
      ans = x.sel[use]
   }#end if
   return(ans)
}#end get.last
#==========================================================================================#
#==========================================================================================#





#==========================================================================================#
#==========================================================================================#
#     This function gets the last element (or the last non-NA element).                    #
#------------------------------------------------------------------------------------------#
get.last <<- function(x,na.rm=FALSE){
   sel = (! na.rm) | (! is.na(x))
   x.sel = x[sel]
   n.sel = length(x.sel)
   if (n.sel == 0){ ans = NaN }else{ ans = x.sel[n.sel]}
   return(ans)
}#end get.last
#==========================================================================================#
#==========================================================================================#





#==========================================================================================#
#==========================================================================================#
#      Function that aggregate the elements of vector x between element i-lag and i.  For  #
# the first few elements, it either assumes circular (take the last elements) or adds NA   #
# entries.                                                                                 #
#------------------------------------------------------------------------------------------#
moving.aggr <<- function(x,pad,fun=mean,circular=FALSE,...){
   nx   = length(x)
   iseq = seq_along(x)

   if (circular){
      ipad = nx - rev(sequence(pad-1) - 1)
      xpad = x[ipad]
   }else{
      xpad = rep(NA_real_,times=pad-1)
   }#end if (circular)

   xmat = embed(x=c(xpad,x),dimension=pad)

   ans  = apply( X = xmat
               , MARGIN = 1
               , FUN    = fun
               , ...
               )#end apply
   return(ans)
}#end moving.aggr
#==========================================================================================#
#==========================================================================================#





#==========================================================================================#
#==========================================================================================#
#      Function that aggregate the elements of vector x between element i-lag and i.  For  #
# the first few elements, it either assumes circular (take the last elements) or adds NA   #
# entries.                                                                                 #
#------------------------------------------------------------------------------------------#
synthesise <<- function(x,fun.int=median,na.rm=FALSE){
   if (is.time(x)){
      #----- Time, use average but convert it to chron before returning. ------------------#
      ans = chron(mean(as.numeric(x),na.rm=na.rm))
      #------------------------------------------------------------------------------------#
   }else if (is.character(x)){
      #----- String, use commonest. -------------------------------------------------------#
      ans = commonest(x,na.rm=na.rm)
      #------------------------------------------------------------------------------------#
   }else if (is.logical(x)){
      #----- Logical, use commonest. ------------------------------------------------------#
      ans = as.logical(commonest(x,na.rm=na.rm))
      #------------------------------------------------------------------------------------#
   }else if (is.integer(x)){
      #----- Integer, use the function specified above. ------------------------------------#
      ans = as.integer(fun.int(x,na.rm=na.rm))
      #------------------------------------------------------------------------------------#
   }else if (is.numeric(x)){
      #----- String, use the function specified above. ------------------------------------#
      ans = mean(x,na.rm=na.rm)
      #------------------------------------------------------------------------------------#
   }else{
      #----- Something else, use commonest just in case. ----------------------------------#
      ans = commonest(x,na.rm=na.rm)
      #------------------------------------------------------------------------------------#
   }#end if
   #---------------------------------------------------------------------------------------#


   #------ Return the aggregated value. ---------------------------------------------------#
   return(ans)
   #---------------------------------------------------------------------------------------#
}#end synthesise
#==========================================================================================#
#==========================================================================================#
